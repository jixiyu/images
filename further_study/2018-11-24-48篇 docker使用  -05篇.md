> 生活日常  
> 2018年11月24日10:12:07         
> 5 篇  
>made by jixi  

### Docker command


----------

+ 官网：[https://www.docker.com/](https://www.docker.com/)  

+ 官网的镜像仓库地址[：https://store.docker.com/](https://store.docker.com/)  

+ 玩法理念：单进程，一个容器最好最专注去做一个事情。虽然它可以既装 MySQL，又装 Nginx 等等，但是让一个容器只做好一件事是最合适的。  

+ 阿里云：[https://dev.aliyun.com/search.html](https://dev.aliyun.com/search.html)



----------
### 一、远程处理

1. 启动docker  

``` thrift
systemctl start docker.service
```
2. 停止docker  

```systemctl stop docker.service```

3. 查看运行状态  

```
systemctl status docker.service
```

4. 简单运行某个镜像  

```
sudo docker run hello-world
```
5. 可以代表一个完整的镜像名有两种方式：  
+ REPOSITORY(仓库):TAG(标签):其中 TAG 表面上不是必须有的，本质是 docker 帮你用 latest 来代替了。latest 这里最好翻译为默认，而不是最新。  
* IMAGE ID(镜像ID):这是一个 Docker 随机给你生成 数字+字母 的字符串  

6. docker官网文档  [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)  

7. 查看docker版本  
```
docker version
```
8. 显示docker系统的信息  
```
docker info
```
9. 从仓库下载镜像到本地  
```
docker pull centos:latest： 获取 CentOS 默认版本镜像  
docker pull centos:7.3.1611：获取 CentOS 7 镜像，下载大小 70M 左右，下面的操作基于此镜像  
```
10. 将一个镜像 push 到 registry 仓库中  
```
docker push myapache:v1
```
11. 从 registry 仓库搜索镜像  
```
docker search -s 3 centos，参数 -s 数字：表示筛选出收藏数（stars值）大于等于 3 的镜像
```


----------
### 二、本地镜像管理

1. 查看当前启动的容器各自占用的系统资源  
```
docker stats  
bin docker stats –no-stream kafkadocker_kafka_1 kafkadocker_zookeeper_1：查看指定容器的占用资源情况
```
2. 显示本地所有的镜像列表  
```
docker images：关注 REPOSITORY(名称)，TAG(标签)，IMAGE ID(镜像ID)三列
```
3. 删除镜像  
```
docker rmi：删除镜像，一般删除镜像前要先删除容器，不然如果镜像有被容器调用会报错

docker rmi 容器ID：删除具体某一个镜像  

docker rmi 仓库:Tag：删除具体某一个镜像  

docker rmi $(docker images -q)，删除所有镜像  

docker rmi -f $(docker images -q)，强制删除所有镜像  


```
4. 为镜像打上标签  
```
docker tag  、
docker tag -f ubuntu:14.04 ubuntu:latest，-f 意思是强制覆盖  
同一个IMAGE ID可能会有多个TAG（可能还在不同的仓库），首先你要根据这些 image names 来删除标签，当删除最后一个tag的时候就会自动删除镜像；  
```
5. 使用 Dockerfile 创建镜像（推荐）  
```
docker build  
docker build . –rm -t runoob/ubuntu:v1，参数 -t，表示：-tag，打标签  
```
6. 显示生成一个镜像的历史命令  
```
docker history：显示生成一个镜像的历史命令，可以看出这个镜像的构建过程，包括：每一层镜像的 ID、指令  
```
7. 将一个镜像保存为一个 tar 包  
```
docker save：将一个镜像保存为一个 tar 包，带 layers 和 tag 信息（导出一个镜像）  

docker save 镜像ID -o /opt/test.tar  
```
8. 导入一个镜像  
```
docker load：从一个 tar 包创建一个镜像（导入一个镜像）  

docker load -i /opt/test.tar  


```


----------
### 三、容器生命周期管理  

1. docker run，运行镜像  
```
docker run -v /java_logs/:/opt/ -d -p 8080:80 –name myDockerNameIsGitNavi -i -t 镜像ID /bin/bash  

-i -t 分别表示保证容器中的 STDIN 开启，并分配一个伪 tty 终端进行交互，这两个是合着用。  

–name 是给容器起了一个名字（如果没有主动给名字，docker 会自动给你生成一个）容器的名称规则：大小写字母、数字、下划线、圆点、中横线，用正则表达式来表达就是：[a-zA-Z0-9_*-]  

-d 容器运行在后台。  

-p 8080:80 表示端口映射，将宿主机的8080端口转发到容器内的80端口。（如果是 -P 参数，则表示随机映射应该端口，一般用在测试的时候）  

-v /java_logs/:/opt/ 表示目录挂载，/java_logs/ 是宿主机的目录，/opt/ 是容器目录  
```
2. 退出即删除容器  
```
docker run –rm –name myDockerNameIsGitNavi -i -t centos /bin/bash，–rm，表示退出即删除容器，一般用在做实验测试的时候  
```
3. 停止后会自动重启  
```
docker run –restart=always -i -t centos /bin/bash，–restart=always 表示停止后会自动重启
```
4. docker exec：对守护式的容器里面执行命令，方便对正在运行的容器进行维护、监控、管理  
```
docker exec -i -t 容器ID /bin/bash，进入正在运行的 docker 容器，并启动终端交互  

docker exec -d 容器ID touch /opt/test.txt，已守护式的方式进入 docker 容器，并创建一个文件  
```
5. docker stop 容器ID，停止容器  
```
docker stop $(docker ps -a -q)，停止所有容器  

docker kill $(docker ps -q) ; docker rm $(docker ps -a -q)，停止所有容器，并删除所有容器  

```
6. 重新启动已经停止的容器  
```
docker start 容器ID，（重新启动，docker run 参数还是保留之前的）  
```
7. 重启容器  
```
docker restart 容器ID
```


----------
### 四、容器管理操作  

1. 列出当前所有 正在运行 的容器  
```
docker ps -a：列出所有的容器（包含历史，即运行过的容器）  

docker ps -l：列出最近一次启动的container  

docker ps -q：列出最近一次运行的container ID  

docker ps -a -l：列出最后一次运行的容器  

docker ps -n x：显示最后 x 个容器，不管是正在运行或是已经停止的  
```
2. 查看容器日志  
```
docker logs -f 容器ID：查看容器日志（如果一些容器不断重启，或是自动停止，可以这样看下）

docker logs 容器ID，获取守护式容器的日志

docker logs -f 容器ID，不断监控容器日志，类似 tail -f

docker logs -ft 容器ID，在 -f 的基础上又增加 -t 表示为每条日志加上时间戳，方便调试

docker logs –tail 10 容器ID，获取日志最后 10 行

docker logs –tail 0 -f 容器ID，跟踪某个容器的最新日志而不必读取日志文件

docker logs -f -t –since=”2018-05-26″ –tail=200 容器ID 根据某个时间读取日志

docker logs -f -t –since=”2018-05-26T11:13:40″ –tail=200 容器ID 根据某个时间读取日志

docker logs -f -t –since=”2018-05-25T11:13:40″ –until “2018-05-26T11:13:40” –tail=200 容器ID 根据某个时间读取日志

docker logs –since 10m 容器ID 查看最近 10 分钟的日志

-f : 表示查看实时日志

-t : 显示时间戳

-since : 显示某个开始时间的所有日志

-tail=200 : 查看最后的 200 条日志


```

----------
### 五、部署一个 Spring Boot 的 Java Web 项目为例  

1. 宿主机环境说明：  


* IP 地址：http://192.168.137.128

* 停止了防火墙：systemctl stop firewalld.service ; systemctl stop iptables.service

* 停止防火墙后重启 Docker 服务：systemctl restart docker.service

* JDK（jdk-8u121-linux-x64.tar.gz）、jar 应用（spring-boot-my-demo.jar），存放宿主机位置：/opt/setups

* Spring Boot 的 jar 应用中配置文件给的端口是：8080，常规情况下的访问路径：http://127.0.0.1:8080/youmeek

2. 下载镜像：docker pull centos:6.8，我的 IMAGE_ID 为：0cd976dc0a98  

3. 运行镜像，实例化为一个容器：docker run -i -t -v /opt/setups:/opt 0cd976dc0a98 /bin/bash

* -v：表示需要将本地宿主机的目录挂载到容器中对应的一个目录上，格式：-v <宿主机目录>:<容器目录>，所以此时对容器此目录的操作，也是等同于对宿主机的目录的操作

4. 在容器里安装 Oracle JDK 8、配置 JDK 环境变量这里不多说  

5. 把容器中 /opt 目录下的 spring-boot-my-demo.jar 拷贝到容器的 root 目录下：cp /opt/spring-boot-my-demo.jar /root  

6. 再容器里新建脚本：vi /root/spring-boot-run.sh，脚本内容如下：  

```
#!/bin/bash  
source /etc/profile  
java -jar /root/spring-boot-my-demo.jar  
```
7. 在容器中对新建脚本增加执行权限：chmod u+x /root/spring-boot-run.sh  

8. 我们启动另外一个终端  

9. 查看我们刚刚运行的容器相关信息：docker ps -a  

* 我们看到了我们刚刚运行的容器 ID（CONTAINER ID）为：a5d544d9b6f9，这个下面要用到  

10. 基于刚刚运行的容器创建新镜像：docker commit a5d544d9b6f9 youmeek/springboot:0.1  

* 查看现在的镜像库：docker images，会发现多了一个 youmeek/springboot 新镜像，镜像 ID 为：7024f230fef9  

11. 运行新镜像，实例化为一个容器，并启动容器中刚刚写的脚本：docker run -d -p 38080:8080 –name springBootJar 7024f230fef9 /root/spring-boot-run.sh  

* -d：表示以“守护模式”执行 spring-boot-run.sh 脚本，此时 jar 中的 log 日志不会出现在输出终端上。  

* -p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 38080 端口，这样就向外界暴露了 38080 端口，可通过 Docker 网桥来访问容器内部的 8080 端口了。 

* –name：表示给新实例容器取的名称，用一个有意义的名称命名即可

12. 查看其实运行的容器：docker ps -a，可以知道我们的新容器 ID：fd21ac056343，名称为：springBootJar

13. 查看这个容器的 jar 应用的 log 输出：docker logs -f fd21ac056343，可以看到 jar 启动后的 log 输出内容

14. 通过浏览器访问容器中的应用：http://192.168.137.128:38080/youmeek/，可以看到 jar 应用的首页可以访问


----------

## END

