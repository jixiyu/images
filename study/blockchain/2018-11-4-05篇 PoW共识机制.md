> 链-共识机制    
> 2018年11月4日20:41:35     
> 05 篇  

### Consensus——PoW


----------


## 1. Proof  of Work 工作量证明  
比特币网络是完全公开的，任何人都可以匿名接入，因此共识协议的稳定性和防攻击性十分关键。

比特币区块链采用了 Proof of Work（PoW）的机制来实现共识，该机制最早于 1998 年在 B-money 设计中提出。

目前，Proof of X 系列中比较出名的一致性协议包括 PoW、PoS 和 DPoS 等，都是通过经济惩罚来限制恶意参与。


----------
## 2.工作量证明  
工作量证明，通过计算来猜测一个数值（nonce），使得拼凑上交易数据后内容的 Hash 值满足规定的上限（来源于 hashcash）。由于 Hash 难题在目前计算模型下需要大量的计算，这就保证在一段时间内，系统中只能出现少数合法提案。反过来，能够提出合法提案，也证明提案者确实已经付出了一定的工作量。  

同时，这些少量的合法提案会在网络中进行广播，收到的用户进行验证后，会基于用户认为的最长链基础上继续难题的计算。因此，系统中可能出现链的分叉（Fork），但最终会有一条链成为最长的链。  

Hash 问题具有不可逆的特点，因此，目前除了暴力计算外，还没有有效的算法进行解决。反之，如果获得符合要求的 nonce，则说明在概率上是付出了对应的算力。谁的算力多，谁最先解决问题的概率就越大。当掌握超过全网一半算力时，从概率上就能控制网络中链的走向。这也是所谓 51% 攻击的由来。  

参与 PoW 计算比赛的人，将付出不小的经济成本（硬件、电力、维护等）。当没有最终成为首个算出合法 nonce 值的“幸运儿”时，这些成本都将被沉没掉。这也保障了，如果有人尝试恶意破坏，需要付出大量的经济成本。也有设计试图将后算出结果者的算力按照一定比例折合进下一轮比赛考虑。
  
    
***有一个很直观的超市付款的例子，可以说明为何这种经济博弈模式会确保系统中最长链的唯一性。***


<img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541335643675.png" width="200" height="300" />   
  
    

假定超市只有一个出口，付款时需要排成一队，可能有人不守规矩要插队。超市管理员会检查队伍，认为最长的一条队伍是合法的，并让不合法的分叉队伍重新排队。新到来的人只要足够理智，就会自觉选择最长的队伍进行排队。这是因为，看到多条链的参与者往往认为目前越长的链具备越大的胜出可能性，从而更倾向于选择长的链。

比特币采用的 POW 工作量证明共识机制，在生成区块时，系统让所有节点 公平地去计算一个随机数，最先寻找到随机数的节点即是这个区块的生产者，并 获得相应的区块奖励。由于哈希函数是散列函数，求解随机数的唯一方法在数学 上只能是穷举，随机性非常好，每个人都可以参与协议的执行。由于梅克尔树根的设置，哈希函数的解的验证过程也能迅速实现。因此，比特币的 POW 共识机 制门槛很低，无需中心化权威的许可，人人都可以参与，并且每一个参与者都无 需身份认证。  

同时，中本聪通过工作量证明的机制破解了无门槛分布式系统的“女巫攻击” 问题。对系统发起攻击需要掌握超过 50%的算力，系统的安全保障较强。   

POW 共识的优点可归纳为:      

- ◼  算法简单，容易实现，节点可自由进入，去中心化程度高。     

- ◼  破坏系统需要投入极大的成本，安全性极高。        

- ◼ 区块生产者的选择通过节点求解哈希函数实现，提案的产生、验证到共识的最终达成过程是一个纯数学问题，节点间无需交换额外的信息即可达成共识，整个过程不需要人性的参与。  

比特币系统的设定在保证安全性的的前提下，牺牲了一部分最终性。因此，POW 共识算法也存在一些问题:    

- ◼  为了保证去中心化程度，区块的确认时间难以缩短。  

- ◼  没有最终性，需要检查点机制来弥补最终性，但随着确认次数的增加，达成共识的可能性也呈指数级地增长。 由于这两个方面的问题，一笔交易为了确保安全，要在 6 个新的区块产生后才能在全网得到确认，也就是说一个交易的确认延迟时间大概为 1 小时，这无法 满足现实世界中对交易实时性要求很高的应用场景。 

   另一方面，POW 共识算法带来了硬件设备的大量浪费。随着比特币价值的 增长，比特币算力竞赛经历了从 CPU 到 GPU，再到 ASIC 专用芯片的阶段。算力强大的 ASIC 芯片矿机将挖矿算法硬件化，而 ASIC 芯片矿机在淘汰后，没有 其他的用途，造成了大量的硬件浪费。


----------
## 3.POW 共识机制能源消耗的必要性  

正如张首晟教授所言，现实世界的熵总是在增加的。POW 共识机制将虚拟 世界和现实世界连接起来，分布式系统中达成共识的过程是一个熵减的过程，这 需要现实世界的熵增来平衡，能量消耗即是提供熵增的平衡方式。

相比于 POW 共识把系统的安全性交给了数学和能量消耗，POS 共识把系 统的安全性交给了人性的博弈。POS 共识是虚拟世界中的一个封闭系统，如果 共识的达成没有付出任何代价，共识的可靠性就可能存疑，人性博弈过程中的混 乱一定会暴露出来。

POS 的升级模式 DPOS 共识机制的共识过程类似于精英代议制，是一种常 设特权的治理架构，容易产生腐化。卢梭对代议制的描述是:“民意一旦被代表， 终究会被扭曲”。DPOS 共识机制是为了效率而生的，它更加适用于对性能要求 极高的相对封闭的商业系统。

而对于 BFT 共识机制，由于节点扩展性的缺陷，其共识节点的选择过程一 样是封闭或者需要验证的，因而也更加适用于相对封闭的应用环境。

信任的产生是需要付出代价的，POW 共识机制所消耗的能量，不仅不是缺 陷，反而是信任产生过程中最有效的平衡机制。


----------
## 4.POW 共识在新一代公链中的大规模应用  



就现实可执行性角度而言，BitMEX 的研究报告指出，POW 共识机制解决 了区块链分叉的选择、数字货币分发、谁产生区块、什么时间产生区块这四个问题，而改进的 POS 共识机制只是解决了区块链分叉的选择问题，其他三个问题 都是开放的，需要更好的解决路径。

包括 Bytom、Aeternity、Aelf、Zilliqa 在内的新一代公链都包含了 POW 共识机制，第二代公链以太坊第三阶段的 Metropolis 也仍是 POS 和 POW 的 混合体。

<img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541335836918.png" width=600 height=800/>  
 <br> </br>
上表所列的公链共识机制选择告诉我们，尽管许多公链有自己独特的设计哲 学，但出于安全性考虑，它们依然绕不开 POW 共识机制的保护。对于开放的、 自治度高的公链环境，POW 共识机制有更好的适用性;而 POS 共识过程的管 理成本很高，在算法更改、分叉选择等重大决策过程中，POS 共识机制才有其 使用价值，但这已经是一种相对中心化的决策机制。  


----------
## 5.区块
比特币区块由区块头和该区块所包含的交易列表组成。区块头大小为80字节，其构成包括：

4字节：版本号 　　

32字节：上一个区块的哈希值 　　

32字节：交易列表的Merkle根哈希值 　　

4字节：当前时间戳 　　

4字节：当前难度值 　　

4字节：随机数Nonce值

此80字节长度的区块头，即为比特币Pow算法的输入字符串。交易列表附加在区块头之后，其中第一笔交易为矿工获得奖励和手续费的特殊交易。

bitcoin-0.15.1源码中区块头和区块定义

``` javascript
class CBlockHeader
{
public:
    //版本号
    int32_t nVersion;
    //上一个区块的哈希值
    uint256 hashPrevBlock;
    //交易列表的Merkle根哈希值
    uint256 hashMerkleRoot;
    //当前时间戳
    uint32_t nTime;
    //当前挖矿难度，nBits越小难度越大
    uint32_t nBits;
    //随机数Nonce值
    uint32_t nNonce;
    //其它代码略
};

class CBlock : public CBlockHeader
{
public:
    //交易列表
    std::vector<CTransactionRef> vtx;
    //其它代码略
};
//代码位置src/primitives/block.h
        </p>enter code here
```

----------
## 6. 难度值  
难度值（difficulty）是矿工们在挖矿时候的重要参考指标，它决定了矿工大约需要经过多少次哈希运算才能产生一个合法的区块。比特币的区块大约每10分钟生成一个，如果要在不同的全网算力条件下，新区块的产生保持都基本这个速率，难度值必须根据全网算力的变化进行调整。简单地说，难度值被设定在无论挖矿能力如何，新区块产生速率都保持在10分钟一个。

难度的调整是在每个完整节点中独立自动发生的。每2016个区块，所有节点都会按统一的公式自动调整难度，这个公式是由最新2016个区块的花费时长与期望时长（期望时长为20160分钟即两周，是按每10分钟一个区块的产生速率计算出的总时长）比较得出的，根据实际时长与期望时长的比值，进行相应调整（或变难或变易）。也就是说，如果区块产生的速率比10分钟快则增加难度，比10分钟慢则降低难度。

这个公式可以总结为如下形式：  

``` 
新难度值 = 旧难度值 * ( 过去2016个区块花费时长 / 20160 分钟 )
```  



工作量证明需要有一个目标值。比特币工作量证明的目标值（Target）的计算公式如下：

```
目标值 = 最大目标值 / 难度值 其中最大目标值为一个恒定值： 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
```

目标值的大小与难度值成反比。比特币工作量证明的达成就是矿工计算出来的区块哈希值必须小于目标值。

比特币工作量证明的过程，就是通过不停的变换区块头（即尝试不同的nouce值）作为输入进行SHA256哈希运算，找出一个特定格式哈希值的过程（即要求有一定数量的前导0）。而要求的前导0的个数越多，代表难度越大。

bitcoin-0.15.1源码中计算挖矿难度代码如下：

``` //nFirstBlockTime即前2016个块的第一个块的时间戳
unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&amp; params)
{
    if (params.fPowNoRetargeting)
        return pindexLast->nBits;

    //计算生成这2016个块花费的时间
    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;
    //不小于3.5天
    if (nActualTimespan &lt; params.nPowTargetTimespan/4)
        nActualTimespan = params.nPowTargetTimespan/4;
    //不大于56天
    if (nActualTimespan > params.nPowTargetTimespan*4)
        nActualTimespan = params.nPowTargetTimespan*4;

    // Retarget
    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);
    arith_uint256 bnNew;
    bnNew.SetCompact(pindexLast->nBits);
    //计算前2016个块的难度总和
    //即单个块的难度*总时间
    bnNew *= nActualTimespan;
    //计算新的难度
    //即2016个块的难度总和/14天的秒数
    bnNew /= params.nPowTargetTimespan;

    //bnNew越小，难度越大
    //bnNew越大，难度越小
    //要求新的难度，难度不低于参数定义的最小难度
    if (bnNew > bnPowLimit)
        bnNew = bnPowLimit;

    return bnNew.GetCompact();
}
//代码位置src/pow.cpp

```



----------
## 7. 工作量证明的过程

我们可以把比特币矿工解这道工作量证明迷题的步骤大致归纳如下：

生成Coinbase交易，并与其他所有准备打包进区块的交易组成交易列表，通过Merkle Tree算法生成Merkle Root Hash
把Merkle Root Hash及其他相关字段组装成区块头，将区块头的80字节数据（Block Header）作为工作量证明的输入
不停的变更区块头中的随机数即nonce的数值，并对每次变更后的的区块头做双重SHA256运算（即SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。
Pow完成的区块向全网广播，其他节点将验证其是否符合规则，如果验证有效，其他节点将接收此区块，并附加在已有区块链之后。之后将进入下一轮挖矿。

bitcoin-0.15.1源码中Pow算法实现：


``` UniValue generateBlocks(std::shared_ptr&lt;CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)
{
    static const int nInnerLoopCount = 0x10000;
    int nHeightEnd = 0;
    int nHeight = 0;

    {   // Don't keep cs_main locked
        LOCK(cs_main);
        nHeight = chainActive.Height();
        nHeightEnd = nHeight+nGenerate;
    }
    unsigned int nExtraNonce = 0;
    UniValue blockHashes(UniValue::VARR);
    while (nHeight &lt; nHeightEnd)
    {
        std::unique_ptr&lt;CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));
        if (!pblocktemplate.get())
            throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't create new block");
        CBlock *pblock = &amp;pblocktemplate->block;
        {
            LOCK(cs_main);
            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);
        }
        //不断变更区块头中的随机数Nonce
        //对变更后的区块头做双重SHA256哈希运算
        //与当前难度的目标值做比对，如果小于目标难度，即Pow完成
        //uint64_t nMaxTries = 1000000;即重试100万次
        while (nMaxTries > 0 &amp;&amp; pblock->nNonce &lt; nInnerLoopCount &amp;&amp; !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {
            ++pblock->nNonce;
            --nMaxTries;
        }
        if (nMaxTries == 0) {
            break;
        }
        if (pblock->nNonce == nInnerLoopCount) {
            continue;
        }
        std::shared_ptr&lt;const CBlock> shared_pblock = std::make_shared&lt;const CBlock>(*pblock);
        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))
            throw JSONRPCError(RPC_INTERNAL_ERROR, "ProcessNewBlock, block not accepted");
        ++nHeight;
        blockHashes.push_back(pblock->GetHash().GetHex());

        //mark script as important because it was used at least for one coinbase output if the script came from the wallet
        if (keepScript)
        {
            coinbaseScript->KeepScript();
        }
    }
    return blockHashes;
}
//代码位置src/rpc/mining.cpp
```
另附bitcoin-0.15.1源码中生成铸币交易和创建新块：  


``` std::unique_ptr&lt;CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript&amp; scriptPubKeyIn, bool fMineWitnessTx)
{
    int64_t nTimeStart = GetTimeMicros();

    resetBlock();

    pblocktemplate.reset(new CBlockTemplate());

    if(!pblocktemplate.get())
        return nullptr;
    pblock = &amp;pblocktemplate->block; // pointer for convenience

    pblock->vtx.emplace_back();
    pblocktemplate->vTxFees.push_back(-1); // updated at end
    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end

    LOCK2(cs_main, mempool.cs);
    CBlockIndex* pindexPrev = chainActive.Tip();
    nHeight = pindexPrev->nHeight + 1;

    //版本号
    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());
    if (chainparams.MineBlocksOnDemand())
        pblock->nVersion = gArgs.GetArg("-blockversion", pblock->nVersion);

    //当前时间戳
    pblock->nTime = GetAdjustedTime();
    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();

    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS &amp; LOCKTIME_MEDIAN_TIME_PAST)
                       ? nMedianTimePast
                       : pblock->GetBlockTime();
    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) &amp;&amp; fMineWitnessTx;

    int nPackagesSelected = 0;
    int nDescendantsUpdated = 0;
    addPackageTxs(nPackagesSelected, nDescendantsUpdated);

    int64_t nTime1 = GetTimeMicros();

    nLastBlockTx = nBlockTx;
    nLastBlockWeight = nBlockWeight;

    //创建铸币交易
    CMutableTransaction coinbaseTx;
    coinbaseTx.vin.resize(1);
    coinbaseTx.vin[0].prevout.SetNull();
    coinbaseTx.vout.resize(1);
    //挖矿奖励和手续费
    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;
    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());
    coinbaseTx.vin[0].scriptSig = CScript() &lt;&lt; nHeight &lt;&lt; OP_0;
    //第一笔交易即为矿工获得奖励和手续费的特殊交易
    pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));
    pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());
    pblocktemplate->vTxFees[0] = -nFees;

    LogPrintf("CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\n", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);

    //上一个区块的哈希值
    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();
    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);
    //当前挖矿难度
    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());
    //随机数Nonce值
    pblock->nNonce         = 0;
    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);

    CValidationState state;
    if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {
        throw std::runtime_error(strprintf("%s: TestBlockValidity failed: %s", __func__, FormatStateMessage(state)));
    }
    int64_t nTime2 = GetTimeMicros();

    LogPrint(BCLog::BENCH, "CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\n", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));

    return std::move(pblocktemplate);
}
//代码位置src/miner.cpp
```

----------
参考博客：

https://github.com/bitcoin/bitcoin  
https://blog.csdn.net/taifei/article/details/78034400    
http://blog.51cto.com/11821908/2059711   

----------
## END

