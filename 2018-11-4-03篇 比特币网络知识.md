> 链-比特币  
> 2018年11月04日 11时44分13秒  
> 03 篇  

### 比特币网络(bitcoin network) 


----------


### 1. p2p网络架构

 1. 比特币采用了基于国际互联网（Internet）的P2P（peer-to-peer）网络架构。

 2. P2P是指位于同一网络中的每台计算机都彼此对等，各个节点共同提供网络服务，不存在任何“特殊”节点。
 3. 每个网络节点以“扁平（flat）”的拓扑结构相互连通。 在P2P网络中不存在任何服务端（server）、中央化的服务、以及层级结构。P2P网络的节点之间交互运作、协同处理：每个节点在对外提供服务的同时也使用网络中其他节点所提供的服务。P2P网络也因此具有可靠性、去中心化，以 及开放性。
 4. 拓扑的含义，所谓“拓扑”就是**把实体抽象成与其大小、形状无关的“点”**，而把连接实体的线路抽象成“线”，**进而以图的形式来表示这些点与线之间关系的方法**，其目的在于研究这些点、线之间的相连关系。表示点和线之间关系的图被称为拓扑结构图。拓扑结构与几何结构属于两个不同的数学概念。
 5. 去中心化控制是设计时的核心原则，它只能通过维持一种扁平化、去中心化的**P2P共识网络**来实现。


----------


### 2. 节点类型及角色  
1. 尽管比特币P2P网络中的各个节点相互对等，**但是根据所提供的功能不同，各节点可能具有不同的角色**。每个比特币节点都是 **路由、区块链数据库、挖矿、钱包服务的功能集合** 。
2. 全节点（full node）:具有所有四个功能：钱包，矿工，完整的区块链数据库和网络路由  

    <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541306514457.png" width="300" hegiht="313" align="center" />  
    
      
      

3. 每个节点都参与全网络的路由功能,每个节点都参与验证并传播交易及区块信息，发现并维持与对等节点的连接。
4.  一些节点保有一份完整的、最新的区块链拷贝，这样的节点被称为“全节点”。**全节点能够独立自主地校验所有交易，而不需借由任何外部参照。**
5.  另外还有一些节点只保留了区块链的一部分，它们通过一种名为 **“简易支付验证（SPV）”的方 式来完成交易验证。这样的节点被称为“SPV节点”，又叫“轻量级节点”。**
6.  SPV节点没有此蓝色圆圈，以示它们没有区块链的完整拷贝。
7.  挖矿节点通过运行在特殊硬件设备上的工作量证明（proof-of-work）算法，以相互竞争的方式创建新的区块。**一些挖矿 节点同时也是全节点，保有区块链的完整拷贝；**
8.  **还有一些参与矿池挖矿的节点是轻量级节点**，它们必须**依赖矿池服务器维护的全节点**进行工作。在全节点用例中，挖矿功能如图中名为“矿工”的黑色圆圈字母“M”所示。

<img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541307410049.png" width="500" hegiht="900" align="center" />    


----------


### 3.扩展比特币网络
1. 运行比特币P2P协议的比特币主网络由大约5000-8000个运行着不同版本比特币核心客户端（Bitcoin Core）的监听节 点、以及几百个运行着各类比特币P2P协议的应用（例如Bitcoin Classic, Bitcoin Unlimited, BitcoinJ, Libbitcoin, btcd, and bcoin等）的节点组成。
2. 许多连接到比特币网络的大型公司运行 着基于Bitcoin核心客户端的全节点客户端，它们具有区块链的完整拷贝及网络节点，但不具备挖矿及钱包功能。这些节点是网络中的边缘路由器（edge  routers），通过它们可以搭建其他服务，例如交易所、钱包、区块浏览器、商家支付处理（merchant payment processing）等。


      <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541309652807.png" width="500" hegiht="1200" align="center" />    


----------


### 4. 比特币传播网络
1. 虽然比特币P2P网络服务于各种各样的节点类型的一般需求，但是对于比特币挖掘节点的专门需求，它显示出太高的网络延迟。
2. 在参加比赛时，比特币矿工必须最大限度地缩短获胜块的传播与下一轮比赛开始之间的时间。在采矿方面，网络延迟与利润率直接相关。
3. 比特币传播网络是一种尝试最小化矿工之间传输块的延迟的网络。原始的比特币传播网络是由核心开发商Matt Corallo于2015年创建的，以便能够以非常低的延迟在矿工之间快速同步块。该网络由世界各地的亚马逊Web服务基础架构上托管的几个专门的节点组成，并且连接大多数矿工和采矿池。
4. 原始的比特币传播网络在2016年被替换为**Fast Internet Bitcoin Relay Engine or FIBRE**，也由核心开发商Matt Corallo创建。 FIBER是一种基于UDP的中继网络，可以中继节点网络内的块。 FIBER实现了compact block，**以进一步减少传输的数据量和网络延迟**。
5. 康奈尔大学研究的另一个中继网络（仍在提案阶段）是 Falcon。 Falcon使用“直通路由”而不是“存储转发”来减少延迟，通过传播块的部分，而不是等待直到接收到完整的块。
6. **传播网络不是比特币的P2P网络的替代品。相反，它们是覆盖网络**，在具有特殊需求的节点之间提供额外的连接像高速公路不是农村道路的替代品，而是交通繁忙的两点之间的快捷方式，您仍然需要小路连接高速公路。


----------


### 5. 网络发现
1. 当新的网络节点启动后，为了能够参与协同运作，它必须发现网络中的其他比特币节点。新的网络节点必须发现至少一个网络中存在的节点并建立连接。
2. 由于比特币网络的拓扑结构并不基于节点间的地理位置，因此各个节点之间的地理信息完全无关。在新节点连接时，可以随机选择网络中存在的比特币节点与之相连。
3. 节点通常采用TCP协议、使用8333端口（该端口号通常是比特币所使用的，除8333端口外也可以指定使用其他端口） 与已知的对等节点建立连接。
4. 在建立连接时，该节点会通过发送一条包含基本认证内容的version消息开始“握手”通信过 程。这一过程包括如下内容：
- ▷ nVersion 定义了客户端所“说出”的比特币P2P协议所采用的版本（例如：70002）。

- ▷ nLocalServices 一组该节点支持的本地服务列表，当前仅支持NODE_NETWORK

- ▷ nTime 当前时间

- ▷ addrYou 当前节点可见的远程节点的IP地址

- ▷ addrMe 本地节点所发现的本机IP地址

- ▷ subver 指示当前节点运行的软件类型的子版本号（例如：”/Satoshi:0.9.2.1/”）

- ▷ BaseHeight 当前节点区块链的区块高度 （version网络消息的具体用例请参见GitHub ）

5. 版本消息始终是任何对等体发送给另一个对等体的第一条消息。
6. 接收版本消息的本地对等体将**检查远程对等体报告的nVersion**，并确定远端对等体**是否兼容。** 如果远程对等体兼容，则本地对等体将确认版本消息，***并通过发送一个verack建立连接。***
7. 新节点如何找到对等体？  
  

   第一种方法是使用多个“DNS种子”来查询DNS，这些DNS服务器提供比特币节点的IP地址列表。
    
8.  其中一些DNS种子提供了稳定的比特币侦听节点的静态IP地址列表。 一些DNS种子是BIND（Berkeley Internet Name Daemon）的自定义实现，***它从搜索器或长时间运行的比特币节点收集的比特币节点地址列表中返回一个随机子集。*** Bitcoin Core客户端包含五种不同DNS种子的名称。
9.  不同DNS种子的所有权和多样性的多样性为初始引导过程提供了高水平的可靠性。 在Bitcoin Core客户端中，使用DNS种子的选项由选项switch -dnsseed控制（默认设置为1，以使用DNS种子）。
10.  不知道网络的引导节点必须被给予至少一个比特币节点的IP地址，之后可以通过进一步介绍来建立连接。 命令行参数-seednode可用于连接到一个节点，仅用于将其用作种子。 在使用初始种子节点形成介绍后，客户端将断开连接并使用新发现的对等体。
11.  对等体之间的握手

  
   <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541311121720.png" width="400" height="500">
   
12. 当建立一个或多个连接后，新节点将一条包含自身IP地址的addr消息发送给其相邻节点。相邻节点再将此条addr消息依 次转发给它们各自的相邻节点，从而保证新节点信息被多个节点所接收、保证连接更稳定。
13. 另外，新接入的节点可以向 它的相邻节点发送getaddr消息，要求它们返回其已知对等节点的IP地址列表。通过这种方式，节点可以找到需连接到 的对等节点，并向网络发布它的消息以便其他节点查找。


   <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541311306052.png" width="400" height="500">
      
14. 节点必须连接到若干不同的对等节点才能在比特币网络中建立通向比特币网络的种类各异的路径（path）。
15. 由于节点可以随时加入和离开，通讯路径是不可靠的。因此，**节点必须持续进行两项工作：在失去已有连接时发现新节点，并在其他节点启动时为其提供帮助。**
16. **节点启动时只需要一个连接**，因为第一个节点可以将它引荐给它的对等节点，而这些节点又会进一步提供引荐。一个节点，如果连接到大量的其他对等节点，这既没必要，也是对网络资源的浪费。
17. 在启动完成 后，节点会记住它最近成功连接的对等节点；因此，当重新启动后它可以迅速与先前的对等节点网络重新建立连接。如果先前的网络的对等节点对连接请求无应答，该节点可以使用种子节点进行重启动。
18. 在运行比特币核心客户端的节点上，您可以使用 getpeerinfo 命令列出对等节点连接信息：

    ```$ bitcoin-cli getpeerinfo```
``` json
    
    {
    "addr" : "85.213.199.39:8333",  
    "services" : "00000001",
    "lastsend" : 1405634126,
    "lastrecv" : 1405634127,
    "bytessent" : 23487651,
    "bytesrecv" : 138679099,
    "conntime" : 1405021768,
    "pingtime" : 0.00000000,
    "version" : 70002,
    "subver" : "/Satoshi:0.9.2.1/",
    "inbound" : false,
    "startingheight" : 310131,
    "banscore" : 0,
    "syncnode" : true
    }
```

19. 用户可以通过提供 -connect= 选项来指定一个或多个IP地址，从而达到覆盖自动节点管理功能并指定IP地址列表的目的。**如果采用此选项，节点只连接到这些选定的节点IP地址，而不会自动发现并维护对等节点之间的连接。**
20. 如果已建立的连接没有数据通信，所在的节点会定期发送信息以维持连接。如果节点持续某个连接长达90分钟没有任何通信，它会被认为已经从网络中断开，网络将开始查找一个新的对等节点。因此，比特币网络会随时根据变化的节点及网络问题进行动态调整，不需经过中心化的控制即可进行规模增减的有机调整。


----------


### 6. 全节点
1. 全节点是指维持包含全部交易信息的完整区块链的节点。
2. 更加准确地说，这样的节点应当被称为完整区块链节点”。在比特币发展的早期，所有节点都是全节点
3. 当前的比特币核心客户端也是完整区块链节点。但在过去的两年中出现了许多 新型客户端，它们不需要维持完整的区块链，而是作为轻量级客户端运行。
4. **完整区块链节点保有完整的、最新的包含全部交易信息的比特币区块链拷贝**，这样的节点可以独立地进行建立并校验区块链，从第一区块（创世区块）一直建立到网络中最新的区块。完整区块链节点可以独立自主地校验任何交易信息，而不需要借助任何其他节点或其他信息来源。完整区块节点通过比特币网络获取包含交易信息的新区块更新，在验证无误后将此更新合并至本地的区块链拷贝之中。
5. **辨别您是否在运行全节点是十分容易的**：只需要查看您的永久性存储设备（如硬盘）是否有超过20GB的空间被用来存储完整区块链即可。如果您需要很大的磁盘空间、并且同步比特币网络耗时2至3天，那么您使用的正是全节点。这就是摆脱中心化管理、获得完全的独立自由所要付出的代价。
6. 尽管目前还有一些使用不同编程语言及软件架构的其他的完整区块链客户端存在，**但是最常用的仍然是比特币核心客户端，它也被称为“Satoshi客户端”**。比特币网络中超过90%的节点运行着各个版本的比特币核心客户端。如前文所述，它 可以通过节点间发送的version消息或通过getpeerinfo命令所得到的子版本字符串“Satoshi”加以辨识，例如 /Satoshi: 0.8.6/。
  


----------


### 7.交换“库存清单”
1. 一个全节点连接到对等节点之后，**第一件要做的事情就是构建完整的区块链**。如果该节点是一个全新节点，那么它就不包含任何区块链信息，**它只知道一个区块——静态植入在客户端软件中的创世区块**。新节点需要下载从0号区块（创世区块）开始的数十万区块的全部内容，才能跟网络同步、并重建全区块链。
2. 同步区块链的过程从发送version消息开始，这是因为该消息中含有的BestHeight字段标示了一个节点当前的区块链高度（区块数量）。节点可以从它的对等节点中得到版本消息，了解双方各自有多少区块，从而可以与其自身区块链所拥 有的区块数量进行比较。
3. 对等节点们会交换一个**getblocks消息**，其中**包含他们本地区块链的顶端区块哈希值（指纹）**。**如果某个对等节点识别出它接收到的哈希值并不属于顶端区块，而是属于一个非顶端区块的旧区块，那么它就能推断出：其自身的本地区块链比其他对等节点的区块链更长。**
4. 拥有更长区块链的对等节点比其他节点有更多的区块，可以识别出哪些区块们是其他节点需要“补充”的。它会识别出第 一批可供分享的500个区块，通过使用inv（inventory）消息把这些区块的哈希值传播出去。缺少这些区块的节点便可以 通过各自发送的getdata消息来请求得到全区块信息，用包含在inv消息中的哈希值来确认是否为正确的被请求的区块， 从而读取这些缺失的区块。
5. 我们假设某节点只含有创世区块。它收到了来自对等节点的inv消息，其中包含了区块链中后500个区块的哈希值。于是它开始向所有与之相连的对等节点请求区块，并通过分摊工作量的方式防止单一对等节点被批量请求所压垮。
6. 该节点会追踪记录其每个对等节点连接上“正在传输”（指那些它已经发出了请求但还没有接收到）的区块数量，并且检查该数量有没有超过上限（ MAX_BLOCKS_IN_TRANSIT_PER_PEER ）。用这种办法，如果一个节点需要更新大量区块，它会在上一请求完成后才发送对新区块的请求，从而允许对等节点控制更新速度，不至于压垮网络。
7. 每一个区块在被接收后就会被添加至区块链中，这一过程详见挖矿一章。随着本地区块链的逐步建立，越来越多的区块被请求和接收，整个过程将一直持续到该节点与全网络完成同步为止。
8. 每当一个节点离线，不管离线时间有多长，这个与对等节点比较本地区块链并恢复缺失区块的过程就会被触发。如果一 个节点只离线几分钟，可能只会缺失几个区块；当它离线长达一个月，可能会缺失上千个区块。但无论哪种情况，它都 会从发送 getblocks 消息开始，收到一个inv响应，接着开始下载缺失的区块。


   <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541314197595.png" width="400" height="500">
   


----------


### 8. 简易支付验证 （Simplified Payment Verification (SPV) ）节点
1. 并非所有的节点都有能力储存完整的区块链。许多比特币客户端被设计成运行在空间和功率受限的设备上，如智能电话、平板电脑、嵌入式系统等。
2. 对于这样的设备，通过简化的支付验证（SPV）的方式可以使它们在不必存储完整区块链的情况下进行工作。这种类型的客端被称为SPV客户端或轻量级客户端。随着比特币的使用热潮，SPV节点逐渐变成比特币节点（尤其是比特币钱包）所采用的最常见的形式。
3. SPV节点只需下载区块头，而不用下载包含在每个区块中的交易信息。由此产生的不含交易信息的区块链，大小只有完整区块链的1/1000
4. SPV节点不能构建所有可用于消费的UTXO的全貌，这是由于它们并不知道网络上所有交易的完整信息。SPV节点验证交易时所使用的方法略有不同，这个方法需依赖对等节点“按需”提供区块链相关部分的局部视图。
5. 每个全节点就像是一个在陌生城市里的游客，他带着一张包含每条街道、每个地址的详细地图。相比之 下，SPV节点就像是这名陌生城市里的游客只知道一条主干道的名字，通过随机询问该城市的陌生人来获取分段道路指示。
6. 虽然两种游客都可以通过实地考察来验证一条街是否存在，但没有地图的游客不知道每个小巷中有哪些街道，也不知道附近还有什么其他街道。没有地图的游客在“教堂街23号”的前面，并不知道这个城市里是否还有其他若干条“教堂街 23号”，也不知道面前的这个是否是要找的那个。对他来说，最好的方式就是向足够多的人问路，并且希望其中一部分人不是要试图抢劫他。
7. **简易支付验证是通过参考交易在区块链中的深度，而不是高度**，来验证它们。一个拥有完整区块链的节点会构造一条验证链，这条链是由沿着区块链按时间倒序一直追溯到创世区块的数千区块及交易组成。***而一个SPV节点会验证所有区块的链（但不是所有的交易），并且把区块链和有关交易链接起来。***


----------


8. **例如，一个全节点要检查第300,000号区块中的某个交易，它会把从该区块开始一直回溯到创世区块的300,000个区块全部都链接起来，并建立一个完整的UTXO数据库，通过确认该UTXO是否还未被支付来证实交易的有效性**。
9. **SPV节点则不能验证UTXO是否还未被支付。**相反地，SPV节点会在该交易信息和它所在区块之间用merkle路径（见“ Merkle 树”章节）建立一条链接。然后SPV节点一直等待，直到序号从300,001到300,006的六个区块堆叠在该交易所在的区块之上，**并通过确立交易的深度是在第300,006区块~第300,001区块之下来验证交易的有效性。**
10. **事实上，如果网络中的其他节点都接受了第300,000区块，并通过足够的工作在该块之上又生成了六个区块，根据代理网关协议，就可以证明该交易不是双重支付。**
11. 如果一个交易实际上不存在，SPV节点不会误认为该交易存在于某区块中。SPV节点会通过请求merkle路径证明以及验证区块链中的工作量证明，来证实交易的存在性。


----------


    ？？？不懂
12. **可是，一个交易的存在是可能对SPV节点“隐藏”的。SPV节点毫无疑问可以证实某个交易的存在性，但它不能验证某个交易（譬如同一个UTXO的双重支付）不存在，这是因为SPV节点没有一份关于所有交易的记录。这个漏洞会被针对SPV节点的拒绝服务攻击或双重支付型攻击所利用。**  
13. 为了防御这些攻击，SPV节点需要随机连接到多个节点，以增加与至少一个可靠节点相连接的概率。这种随机连接的需求意味着SPV节点也容易受到网络分区攻击或Sybil攻击。在后者情况中，SPV节点被连接到虚假节点或虚假网络中，没有通向可靠节点或真正的比特币网络的连接。


----------

    重点
14. 提示 完整的区块链节点是通过检查整个链中在它之下的数千个区块来保证这个UTXO没有被支付，从而验证交易。而 SPV节点是通过检查在其上面的区块将它压在下面的深度来验证交易。
15. SPV节点使用的是一条getheaders消息，而不是getblocks消息来获得区块头。发出响应的对等节点将用一条headers 消息发送多达2000个区块头。这一过程和全节点获取所有区块的过程没什么区别。SPV节点还在与对等节点的连接上设置了过滤器，用以过滤从对等节点发来的未来区块和交易数据流。任何目标交易都是通过一条getdata的请求来读取的。对等节点生成一条包含交易信息的tx消息作为响应。
16. 区块头的同步过程：
   <img src="https://www.github.com/jixiyu/images3/raw/master/小书匠/1541316484734.png" width="400" height="500">

17. 由于SPV节点需要读取特定交易从而选择性地验证交易，这样就又产生了隐私风险。与全区块链节点收集每一个区块内的全部交易所不同的是，**SPV节点对特定数据的请求可能无意中透露了钱包里的地址信息**。例如，**监控网络的第三方可以跟踪某个SPV节点上的钱包所请求的全部交易信息，并且利用这些交易信息把比特币地址和钱包的用户关联起来，从而损害了用户的隐私。**

下一篇将讲到Bloom过滤器。
----------
## END