> 密码学和共识算法  
> 2018年11月7日16:11:28         
> 18 篇  
>made by jixi

### AES 算法的底层原理


----------

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577092375.png)

![](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577099872.png)

![](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577613000.png)

AES的总体加密流程：

1. 把明文按照128bit拆分成若干个明文块。

2. 按照选择的填充方式来填充最后一个明文块。

3. 每一个明文块利用AES加密器和密钥，加密成密文块。

4. 拼接所有的密文块，成为最终的密文结果。  

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577658231.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577667263.png)

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577686548.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577692491.png)

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577718321.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577723528.png)

具体分成多少轮呢？  
 
初始轮（Initial Round）  1次  

普通轮（Rounds）          N次  

最终轮（Final Round）   1次  

上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。  

除去初始轮，各种Key长度对应的轮数如下：  

AES128：10轮  

AES192：12轮  

AES256：14轮  

不同阶段的Round有不同的处理步骤。  


初始轮只有一个步骤：  

加轮密钥（AddRoundKey）  



普通轮有四个步骤：  

**字节代替（SubBytes）**   

**行移位（ ShiftRows**）  

**列混淆（MixColumns）**  

**加轮密钥（AddRoundKey）**  



最终轮有三个步骤：

**字节代替（SubBytes**）

**行移位（ShiftRows）**

**加轮密钥（AddRoundKey）**  

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577884038.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577890443.png)

**1.字节替代（SubBytes）**

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577901136.png)

首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。


所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为S盒（Subtitution Box）的16X16大小的二维常量数组。


假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。

**2.行移位（ShiftRows）**

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577962149.png)

这一步很简单，就像图中所描述的：

第一行不变  

第二行循环左移1个字节  

第三行循环左移2个字节  

第四行循环左移3个字节  



**3.列混淆（MixColumns）**
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577985217.png)

这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。  


**4.加轮密钥（AddRoundKey）**


![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578004989.png)

这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。


让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。


需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：扩展密钥（KeyExpansions）。


**扩展密钥（ KeyExpansions ）**


AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。


后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。


W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578145552.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578150695.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578156154.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578172755.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578177137.png)


**1. ECB模式**


ECB模式（Electronic Codebook Book）是最简单的工作模式，在该模式下，每一个明文块的加密都是完全独立，互不干涉的。

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578220652.png)

这样的好处是什么呢？

1.简单

2.有利于并行计算


缺点同样也很明显：

相同的明文块经过加密会变成相同的密文块，因此安全性较差。

**2. CBC模式**


CBC模式（Cipher Block Chaining）引入了一个新的概念：初始向量IV（Initialization Vector）。


IV是做什么用的呢？它的作用和MD5的“加盐”有些类似，目的是防止同样的明文块始终加密成同样的密文块。
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578245296.png)

从图中可以看出，CBC模式在每一个明文块加密前会让明文块和一个值先做异或操作。IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它 前一个明文块所加密出的密文块相异或。


这样以来，相同的明文块加密出的密文块显然是不一样的。


CBC模式的好处是什么呢？

安全性更高


坏处也很明显：

1.无法并行计算，性能上不如ECB

2.引入初始化向量IV，增加复杂度。
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578261831.png)


----------
## END

