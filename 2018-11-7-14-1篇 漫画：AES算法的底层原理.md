> 密码学和共识算法  
> 201       
> 18 篇  
>made by jixi

### AES 算法的底层原理


----------

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577092375.png)

![](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577099872.png)

![](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577613000.png)

AES的总体加密流程：

1. 把明文按照128bit拆分成若干个明文块。

2. 按照选择的填充方式来填充最后一个明文块。

3. 每一个明文块利用AES加密器和密钥，加密成密文块。

4. 拼接所有的密文块，成为最终的密文结果。  

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577658231.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577667263.png)

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577686548.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577692491.png)

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577718321.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577723528.png)

具体分成多少轮呢？  
 
初始轮（Initial Round）  1次  

普通轮（Rounds）          N次  

最终轮（Final Round）   1次  

上一期我们提到，AES的Key支持三种长度：AES128，AES192，AES256。Key的长度决定了AES加密的轮数。  

除去初始轮，各种Key长度对应的轮数如下：  

AES128：10轮  

AES192：12轮  

AES256：14轮  

不同阶段的Round有不同的处理步骤。  


初始轮只有一个步骤：  

加轮密钥（AddRoundKey）  



普通轮有四个步骤：  

**字节代替（SubBytes）**   

**行移位（ ShiftRows**）  

**列混淆（MixColumns）**  

**加轮密钥（AddRoundKey）**  



最终轮有三个步骤：

**字节代替（SubBytes**）

**行移位（ShiftRows）**

**加轮密钥（AddRoundKey）**  

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577884038.png)
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577890443.png)

**1.字节替代（SubBytes）**

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577901136.png)

首先需要说明的是，16字节的明文块在每一个处理步骤中都被排列成4X4的二维数组。


所谓字节替代，就是把明文块的每一个字节都替代成另外一个字节。替代的依据是什么呢？依据一个被称为S盒（Subtitution Box）的16X16大小的二维常量数组。


假设明文块当中a[2,2] = 5B（一个字节是两位16进制），那么输出值b[2,2] = S[5][11]。

**2.行移位（ShiftRows）**

![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577962149.png)

这一步很简单，就像图中所描述的：

第一行不变  

第二行循环左移1个字节  

第三行循环左移2个字节  

第四行循环左移3个字节  



**3.列混淆（MixColumns）**
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541577985217.png)

这一步，输入数组的每一列要和一个名为修补矩阵（fixed matrix）的二维常量数组做矩阵相乘，得到对应的输出列。  

**4.加轮密钥（AddRoundKey）**
![enter description here](https://www.github.com/jixiyu/images3/raw/master/小书匠/1541578004989.png)

这一步是唯一利用到密钥的一步，128bit的密钥也同样被排列成4X4的矩阵。


让输入数组的每一个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]。


需要补充一点，加密的每一轮所用到的密钥并不是相同的。这里涉及到一个概念：扩展密钥（KeyExpansions）。


**扩展密钥（ KeyExpansions ）**

AES源代码中用长度 4 * 4 *（10+1） 字节的数组W来存储所有轮的密钥。W{0-15}的值等同于原始密钥的值，用于为初始轮做处理。


后续每一个元素W[i]都是由W[i-4]和W[i-1]计算而来，直到数组W的所有元素都赋值完成。


W数组当中，W{0-15}用于初始轮的处理，W{16-31}用于第1轮的处理，W{32-47}用于第2轮的处理 ......一直到W{160-175}用于最终轮（第10轮）的处理。

----------

### 2. 




----------
## END

